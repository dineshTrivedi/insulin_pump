\chapter{Módulo de controle de infusão de insulina}
Este trabalho tem o objetivo de estudar e desenvolver um protótipo do módulo de controle da bomba de infusão de insulina, para o desenvolvimento vamos utilizar o microcontrolador PIC18F452. Módulo este responsável por controlar o funcionamento da bomba em função dos parâmetros recebidos e pré estabelecidos. É possível configurar a quantidade a ser infundido no período de 24 horas, infusão basal, e, além disso e mais importante, o desenvolvimento foi feito em cima do simulador proteus e devido a possibilidade de mudanças possíveis o sistema foi montado de forma que deixa os módulos desacoplados. Para isso foi utilizado o conceito OOC, \emph{Object Orientated Programming in ANSI-C}, o que possibilitou o uso de \emph{Design Patterns}.

\section{\emph{OOC - \emph{Object Orientated Programming in ANSI-C}}}
Segundo \cite{schreiner1993object}, OOC, \emph{Object Orientated Programming in ANSI-C}, é uma forma de se aproveitar as diversas vantagens da Programação orientada objeto. Vantagens essas proporcionadas por linguagens como C++, java, python, smalltalk e outras. OOC, necessita da sepação em dois arquivo distindos, separação semelhante a do c++: o primeiro possui a extensão por padrão ".h" e contém apenas a declarações de interfaces e classes, já o segundo, com extensão ".c", possui a devida implementação. Este é um conceito considerado mais denso do que Orientação Objeto propriamente dito, isso se deve ao fato de que o usuário implemente componentes como: 

\begin{itemize}
\item Interface: Define-se interface como uma \emph{struct} com ponteiros para funções, de forma que o \emph{bind} das funções é feito na hora da criação de um objeto de uma classe que implemente essa interface;
\item Classe: Da mesma forma que as interfaces, é uma \emph{struct} em que os atributos são ponteiros para função, entretanto tem os \emph{binds} definidos em uma função de criação(construtor) pertencente a essa classe, ou módulo;
\item Construtor: Função da classe em que faz o \emph{bind} de cada ponteiro para cada função da classe, alocações dinâmicas e outras operações que podem ser definidas de acordo com a necessidade de cada classe;
\item Destrutor: Basicamente a liberação de todos os recursos alocados pelo construtor e funções que a classe utilizou;
\item Public: Declaração da variável como atributo da \emph{struct} ou no arquivo \emph{header};
\item Private: Declaração da variável fora da \emph{struct}, no arquivo que tem a implementação das funções da classe.
\end{itemize}

O conceito de polimorfismo e abstração de dados se dá pela associação de um mesmo ponteiros de função de uma classe ou interface à funções diferente, variando em função da classe mais especializada que está sendo abstraída.

Obviamente é uma simulação da consolidada programação orientada objeto e possui limitações como: Programação genérica sem validação em tempo de compilação, sintaxe mais complexa, geração de código implícito, entre outros. Entretanto ainda permite reutilização de código e, como dito anteriormente, abstração de dados.

\section{\emph{Design Patterns}}
Na engenharia de \emph{software}, um \emph{Design Patterns} ou padrão de projeto é uma solução repetível geral para um problema comumente ocorre em \emph{design} de \emph{software}. Um padrão de projeto não é um projeto acabado que pode ser transformado diretamente em código. É uma descrição ou modelo de como resolver um problema que pode ser utilizado em diversas situações diferentes. \cite{shalloway2004design}.

\subsection{Usos de \emph{Design Patterns}}

Os \emph{Design Patterns} podem acelerar o processo de desenvolvimento, fornecendo testados e comprovados paradigmas de desenvolvimento. O \emph{design} de \emph{software} eficaz requer considerar as questões que não podem tornar-se visível até mais tarde na implementação. Reutilizar \emph{Design Patterns} ajuda a prevenir situações que podem causar grandes problemas e melhora a legibilidade do código para programadores e arquitetos familiarizados com os padrões.

Muitas vezes, as pessoas só entendem como aplicar certas técnicas de \emph{design} de \emph{software} para determinados problemas. Estas técnicas são difíceis de aplicar a uma ampla gama de problemas. Os \emph{Design Patterns} fornecem soluções gerais, documentadas em um formato que não requer especificidades ligadas a um problema particular \cite{shalloway2004design}.

Segundo \cite{shalloway2004design}, além disso, os padrões permitem que os desenvolvedores se comuniquem usando nomes bem conhecidos e bem compreendidos para interações de software. \emph{Design Patterns} comuns podem ser melhorados ao longo do tempo, tornando-os mais robustos do que os projetos ad-hoc, ou seja, problemas específicos. Os \emph{Design Patterns} podem ser divididos em:

\begin{itemize}
\item \emph{Creational design patterns}: Estes \emph{Design Patterns} tem tudo a ver com padrões de instanciação de classe. Esse padrão pode ser dividido em padrões de criação de classe e de criação de objetos. Enquanto os padrões de criação de classe usam a herança de forma eficaz no processo de instanciação, os padrões de criação de objeto usam a delegação de forma eficaz para ter o trabalho de criação feito. 
\item \emph{Structural design patterns}: Este \emph{Design Pattern} tem tudo a ver com composição de classe e objetos. Padrão estrutural de classe usa a herança para compor interfaces. Padrão estrutural de objeto define formas de compor objetos para obter novas funcionalidades.
\item \emph{Behavioral design patterns}: São os padrões que são mais especificamente relacionadas com a comunicação entre objetos.
\end{itemize}

\subsection{\emph{Factory Method}}
Segundo \cite{shalloway2004design}, \emph{factory method} foi um dos \emph{Design Patterns} escolhidos para esse projeto. Seus objetivos principais são:

\begin{itemize}
\item Definir uma interface para criar um objeto, mas deixa as subclasses decidirem qual classe instanciar. Factory Method permite adiar a instanciação da classe para a subclasses;
\item Definir um construtor \emph{virtual};
\item Operador \emph{new} é considerado perigoso.
\end{itemize}

Esse \emph{Design Patterns} foi utilizado no módulo que faz uso do \emph{display} de LCD para que a troca de seu tipo ficasse isolado do restante do sistema e que um futura troca possa ser feita com o menor impacto possível. A Figura \ref{fig:factorymethod} representa sua etsrutura em UML. \newpage

\begin{figure}[htp]
	\centering
	\includegraphics[scale=0.4]{images/Factory_Method.png}
	\caption{Estrutura do padrão \emph{Factory Method}}	
	\label{fig:factorymethod}
	\cite{shalloway2004design}
\end{figure}

\section{Proteus}

No desenvolvimento deste TCC o simulador Proteus foi usado para montar o ambiente de tesste. Para testes, o circuito teve seu desenvolvimento em função dos seguintes componentes: microcontrolador da família PIC, PIC18F452, motor de passo, \emph{display} de LCD 2x16, botões e driver para o motor de passo. A Figura \ref{fig:proteus} representa a imagem do \emph{Software}.

\begin{figure}[htp]
	\centering
	\includegraphics[scale=0.5]{images/proteus.png}
	\caption{\emph{Software} Proteus}	
	\label{fig:proteus}
\end{figure}

\section{Arquitetura do Software}

O \emph{Software} foi desenvolvido de forma modular para que as funções fossem facilmente testadas, modificadas e evoluídas, a Figura \ref{fig:arquiteturageral} representa a estrutura citada. A divisão do \emph{Software} foi feita da seguinte forma: config, insulimpump, lcd, menu, motor, timerMotor e principal. 

\begin{figure}[htp]
	\centering
	\includegraphics[scale=0.7]{images/arquitetura.png}
	\caption{Estrutura do \emph{Software}}	
	\label{fig:arquiteturageral}
\end{figure}

\subsection{Módulo Config}

Módulo feito para centralizar todas as configurações do sistema, utilizado, basicamente, por quase todos os demais módulos. Seguindo parte do conceito de OOC, pois foi possível utilizar a ideia de \emph{private} e \emph{public} para as variáveis. Entretanto não foi criada nenhuma \emph{struct} de forma que representasse uma classe. A Figura \ref{fig:driagramaclasseconfig} representa o diagrama de classe desse módulo. \newpage


\begin{figure}[htp]
	\centering
	\includegraphics[scale=1]{images/classe_GlobalConfig.png}
	\caption{Diagrama de classe GlobalConfig}	
	\label{fig:driagramaclasseconfig}
\end{figure}

Quando se diz \emph{private} e \emph{public} é o fato de adicionar as variáveis no arquivo GlobalConfig.h, \emph{private}, ou GlobalConfig.c, \emph{public}. A principal parametrização desse módulo é a quantidade que o repositório de insulina suporta. Para modificar seu valor basta alterar o \emph{define} QUANTIDADE\_TOTAL\_RESERVATORIO\_INSULINA. Esse valor representa a quantidade de insulina existente no reservatório na escala da infusão mínima da bomba.

\subsection{Módulo InsulinPump}

O módulo InsulinPump é responsável pela abstração das funções da bomba para o resto do sistema. Funções simples para o resto do sistema como: inicializar variáveis de controle, iniciar operação, parar operação - principalmente para configurações da bomba -, injetar e retornar a quantidade inserida naquela hora. Seguindo o conceito OOC foi criada uma "interface", IInsulinPump, e a "classe" concreta InsulinPump. A Figura \ref{fig:diagramainsulinpump} representa a relação e diagrama de classe dos elementos citados anteriormente.

\begin{figure}[htp]
	\centering
	\includegraphics[scale=1]{images/classe_insulinpump.png}
	\caption{Diagrama de classe InsulinPump}	
	\label{fig:diagramainsulinpump}
\end{figure}

\subsection{Módulo Lcd}

Esse módulo é responsável pelo isolamento do \emph{display} de LCD do resto do sistema. Composto por um \emph{factory}, que retorna um obeto de controle de acordo com o parâmetro passado, uma "interface" para possibilitar essa abstração e as classes concretas, no caso existe apenas a classe concreta para \emph{display} 2x16(2 linhas por 16 colunas). A Figura \ref{fig:diagramalcd} representa a relação e diagrama de classe dos elementos citados anteriormente.

\begin{figure}[htp]
	\centering
	\includegraphics[scale=0.8]{images/classe_lcd.png}
	\caption{Diagrama de classe Lcd}	
	\label{fig:diagramalcd}
\end{figure}

\subsection{Módulo Menu}

O módulo de menu foi criado para abstrair todos as possíveis situações e estados da bomba. Foi criado de uma forma muito simples e é equivalente a uma máquina de estado. Utiliza uma "inteface" que é implementado por todos os tipos de menu existentes como: menu de confuguração da bomba, menu da bomba em execução, menu de confirmação do estado do reservatório e outros. A Figura \ref{fig:classemenu} representa as relações entre os componentes, ou "classes", do módulo e demonstra como é simples a criação de novos menus.

\begin{figure}[htp]
	\centering
	\includegraphics[scale=1]{images/classe_menu.png}
	\caption{Diagrama de classe Menu}	
	\label{fig:classemenu}
\end{figure}

\subsection{Módulo Motor}

O módulo motor, tem como resposabilidade abstrair todas as operações necessárias para o controle do motor de forma que o resto do sistema não saiba qual motor está utilizando. Isso é possível devido a "interface" criada para abstração e o uso de um \emph{Factory} que retorna o motor que deve ser utilizado de acordo com um parâmetro global, localizado no módulo config. A figura \ref{fig:classemotor} representa as relações existentes nesse módulo. \newpage


\begin{figure}[htp]
	\centering
	\includegraphics[scale=0.8]{images/classe_motor.png}
	\caption{Diagrama de classe Motor}	
	\label{fig:classemotor}
\end{figure}

\subsection{Módulo TimerMotor}

O módulo TimerMotor armazena todos os dados do contador para o uso dos motores. Abstrai a configuração do timer em função do \emph{hardware} para o resto do sistema. Dessa forma o sistema só precisa se preocupar em: fazer configuração inicial(inicializar variáveis), iniciar timer, parar timer. A Figura \ref{fig:classe_timer_motor} representa a relação citada acima.

\begin{figure}[htp]
	\centering
	\includegraphics[scale=1]{images/classe_timer_motor.png}
	\caption{Diagrama de classe TimerMotoror}	
	\label{fig:classe_timer_motor}
\end{figure}


\subsection{Módulo Principal}

Devido a forma modular com  que foi implementado o sistema esse tornou-se o módulo mais simples. Ficou responsável apenas pela interrupção, específico do hardware, chamar os métodos de incialização dos módulos do lcd, TimerMotor e InsulinPump, e um loop principal, extremamente simples, que exibe o Menu, correspondente ao estado atual, e recebe o retorno do próprio menu em questão para navegar entre os menus existente.